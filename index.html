<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WEBカフェラテアート</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 10px;
            background: linear-gradient(27deg, #fff7f3 0%, #574c46 100%);
            color: #f5e6d3;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        h1 {
            margin-bottom: 5px;
            color: #f4d9b8;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: clamp(1.5rem, 5vw, 2rem);
            text-align: center;
        }

        .subtitle {
            color: #c9a876;
            margin-bottom: 20px;
            font-style: italic;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 650px;
            padding: 0 10px;
        }

        .canvas-container {
            position: relative;
            border-radius: 50%;
            overflow: hidden;
            box-shadow:
                0 10px 40px rgba(0,0,0,0.5),
                inset 0 0 20px rgba(0,0,0,0.3);
            background: radial-gradient(circle, #1a0f08 0%, #0d0705 100%);
            width: min(90vw, 600px);
            height: min(90vw, 600px);
            max-width: 600px;
            max-height: 600px;
        }

        canvas {
            display: block;
            cursor: crosshair;
            border-radius: 50%;
            width: 100%;
            height: 100%;
        }

        .controls {
            background: rgba(74, 44, 26, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(201, 168, 118, 0.3);
            width: 100%;
            max-width: 500px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 140px;
        }

        label {
            font-size: 12px;
            color: #c9a876;
        }

        input[type="range"] {
            width: 100%;
            min-width: 120px;
            accent-color: #c9a876;
        }

        button {
            background: linear-gradient(135deg, #c9a876 0%, #a88a5e 100%);
            color: #2c1810;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            font-size: 14px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(201, 168, 118, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .info {
            font-size: 14px;
            color: #c9a876;
            text-align: center;
            max-width: 90%;
            margin-bottom: 10px;
            padding: 0 10px;
        }

        .value-display {
            color: #f4d9b8;
            font-weight: bold;
        }

        .presets {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            padding: 0 10px;
        }

        .preset-btn {
            padding: 8px 16px;
            font-size: 14px;
            flex: 1;
            min-width: 150px;
            max-width: 250px;
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 3px;
            }

            .info {
                font-size: 12px;
                margin-bottom: 10px;
            }

            .container {
                gap: 10px;
            }

            .controls {
                padding: 10px;
                gap: 10px;
            }

            .control-group {
                min-width: 120px;
            }

            label {
                font-size: 11px;
            }

            button {
                padding: 10px 20px;
                font-size: 13px;
            }

            .preset-btn {
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <h1>WEBカフェラテアート</h1>
    <div class="info">マウスをドラッグしてミルクを注いでください</div>

    <div class="container">
        <div class="canvas-container">
            <canvas id="canvas" width="600" height="600"></canvas>
        </div>

        <div class="controls">
            <div class="control-group" style="display: none;">
                <label>粘性: <span class="value-display" id="viscosity-value">0.003000</span></label>
                <input type="range" id="viscosity" min="10" max="500" value="300" step="5">
            </div>

            <div class="control-group" style="display: none;">
                <label>拡散: <span class="value-display" id="diffusion-value">0.000001</span></label>
                <input type="range" id="diffusion" min="1" max="50" value="1" step="1">
            </div>

            <div class="control-group" style="display: none;">
                <label>注ぐ強さ: <span class="value-display" id="force-value">5</span></label>
                <input type="range" id="force" min="5" max="50" value="5" step="5">
            </div>

            <div class="control-group" style="display: none;">
                <label>ミルクの濃さ: <span class="value-display" id="density-value">300</span></label>
                <input type="range" id="density" min="50" max="300" value="300" step="10">
            </div>
        </div>

        <div class="presets">
            <button class="preset-btn" onclick="resetCoffee()">☕ 新しいコーヒー</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const N = 128;
        const SIZE = (N + 2) * (N + 2);
        const DT = 0.1;

        // 流体シミュレーションの状態
        let u = new Float32Array(SIZE);
        let v = new Float32Array(SIZE);
        let u_prev = new Float32Array(SIZE);
        let v_prev = new Float32Array(SIZE);
        let dens = new Float32Array(SIZE);
        let dens_prev = new Float32Array(SIZE);

        // コーヒーの背景色（ミルクが混ざっていない状態）
        let coffee = new Float32Array(SIZE);

        // マウス状態
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let pmouseX = 0, pmouseY = 0;

        // パラメータ
        let viscosity = 0.005;
        let diffusion = 0.000001;
        let force = 5;
        let densityAmount = 300;

        function IX(i, j) {
            return i + (N + 2) * j;
        }

        function set_bnd(b, x) {
            const centerX = (N + 2) / 2;
            const centerY = (N + 2) / 2;
            const radius = N * 0.45;

            for (let i = 1; i <= N; i++) {
                x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                x[IX(N + 1, i)] = b === 1 ? -x[IX(N, i)] : x[IX(N, i)];
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
            }

            // 円形の境界条件（カップの縁で跳ね返る）
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    const dx = i - centerX;
                    const dy = j - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > radius) {
                        // 境界の外側では速度を反転
                        if (b === 1) { // u velocity
                            x[IX(i, j)] = 0;
                        } else if (b === 2) { // v velocity
                            x[IX(i, j)] = 0;
                        } else { // density
                            x[IX(i, j)] *= 0.5;
                        }
                    }
                }
            }

            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N + 1)] = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
            x[IX(N + 1, 0)] = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
            x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
        }

        function lin_solve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            for (let k = 0; k < 20; k++) {
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        x[IX(i, j)] = (x0[IX(i, j)] + a * (
                            x[IX(i + 1, j)] + x[IX(i - 1, j)] +
                            x[IX(i, j + 1)] + x[IX(i, j - 1)]
                        )) * cRecip;
                    }
                }
                set_bnd(b, x);
            }
        }

        function diffuse(b, x, x0, diff, dt) {
            const a = dt * diff * N * N;
            lin_solve(b, x, x0, a, 1 + 4 * a);
        }

        function advect(b, d, d0, u, v, dt) {
            const dt0 = dt * N;
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    let x = i - dt0 * u[IX(i, j)];
                    let y = j - dt0 * v[IX(i, j)];

                    if (x < 0.5) x = 0.5;
                    if (x > N + 0.5) x = N + 0.5;
                    let i0 = Math.floor(x);
                    let i1 = i0 + 1;

                    if (y < 0.5) y = 0.5;
                    if (y > N + 0.5) y = N + 0.5;
                    let j0 = Math.floor(y);
                    let j1 = j0 + 1;

                    let s1 = x - i0;
                    let s0 = 1 - s1;
                    let t1 = y - j0;
                    let t0 = 1 - t1;

                    d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                                  s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            set_bnd(b, d);
        }

        function project(u, v, p, div) {
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    div[IX(i, j)] = -0.5 * (
                        u[IX(i + 1, j)] - u[IX(i - 1, j)] +
                        v[IX(i, j + 1)] - v[IX(i, j - 1)]
                    ) / N;
                    p[IX(i, j)] = 0;
                }
            }
            set_bnd(0, div);
            set_bnd(0, p);
            lin_solve(0, p, div, 1, 4);

            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    u[IX(i, j)] -= 0.5 * N * (p[IX(i + 1, j)] - p[IX(i - 1, j)]);
                    v[IX(i, j)] -= 0.5 * N * (p[IX(i, j + 1)] - p[IX(i, j - 1)]);
                }
            }
            set_bnd(1, u);
            set_bnd(2, v);
        }

        function dens_step(x, x0, u, v, diff, dt) {
            for (let i = 0; i < SIZE; i++) {
                x[i] += dt * x0[i];
            }
            diffuse(0, x0, x, diff, dt);
            advect(0, x, x0, u, v, dt);
        }

        function vel_step(u, v, u0, v0, visc, dt) {
            for (let i = 0; i < SIZE; i++) {
                u[i] += dt * u0[i];
                v[i] += dt * v0[i];
            }
            diffuse(1, u0, u, visc, dt);
            diffuse(2, v0, v, visc, dt);
            project(u0, v0, u, v);
            advect(1, u, u0, u0, v0, dt);
            advect(2, v, v0, u0, v0, dt);
            project(u, v, u0, v0);
        }

        // マウスイベント
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;
            pmouseX = mouseX;
            pmouseY = mouseY;
        });

        canvas.addEventListener('mousemove', (e) => {
            pmouseX = mouseX;
            pmouseY = mouseY;
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;

            if (mouseDown) {
                addMilk();
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseDown = true;
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;
            pmouseX = mouseX;
            pmouseY = mouseY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            pmouseX = mouseX;
            pmouseY = mouseY;
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;

            if (mouseDown) {
                addMilk();
            }
        });

        canvas.addEventListener('touchend', () => {
            mouseDown = false;
        });

        // ミルクを注ぐ
        function addMilk() {
            const i = Math.floor((mouseX / canvas.width) * N) + 1;
            const j = Math.floor((mouseY / canvas.height) * N) + 1;

            if (i >= 1 && i <= N && j >= 1 && j <= N) {
                const dx = mouseX - pmouseX;
                const dy = mouseY - pmouseY;

                // 速度を追加
                const radius = 3;
                for (let di = -radius; di <= radius; di++) {
                    for (let dj = -radius; dj <= radius; dj++) {
                        const ni = i + di;
                        const nj = j + dj;
                        if (ni >= 1 && ni <= N && nj >= 1 && nj <= N) {
                            const dist = Math.sqrt(di * di + dj * dj);
                            if (dist <= radius) {
                                const factor = (1 - dist / radius);
                                u_prev[IX(ni, nj)] += dx * force * factor;
                                v_prev[IX(ni, nj)] += dy * force * factor;
                                dens_prev[IX(ni, nj)] += densityAmount * factor;
                            }
                        }
                    }
                }
            }
        }

        // カフェアート風の描画
        function draw() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            const cellWidth = canvas.width / N;
            const cellHeight = canvas.height / N;

            const centerX = N / 2;
            const centerY = N / 2;
            const cupRadius = N * 0.45;

            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    const dx = i - centerX;
                    const dy = j - centerY;
                    const distFromCenter = Math.sqrt(dx * dx + dy * dy);

                    // カップの外側は描画しない
                    if (distFromCenter > cupRadius) {
                        continue;
                    }

                    const d = dens[IX(i, j)];
                    const c = coffee[IX(i, j)];

                    // ミルク（白）とコーヒー（茶色）をブレンド
                    const milkAmount = Math.min(1, d / 100);

                    // コーヒー色: 濃い茶色
                    const coffeeR = 40 + c * 0.3;
                    const coffeeG = 25 + c * 0.2;
                    const coffeeB = 15 + c * 0.1;

                    // ミルク色: クリーム色
                    const milkR = 245;
                    const milkG = 235;
                    const milkB = 220;

                    // ブレンド
                    let r = coffeeR * (1 - milkAmount) + milkR * milkAmount;
                    let g = coffeeG * (1 - milkAmount) + milkG * milkAmount;
                    let b = coffeeB * (1 - milkAmount) + milkB * milkAmount;

                    // カップの縁に向かって暗くする（ビネット効果）
                    const vignette = 1 - (distFromCenter / cupRadius) * 0.3;
                    r *= vignette;
                    g *= vignette;
                    b *= vignette;

                    r = Math.min(255, Math.max(0, r));
                    g = Math.min(255, Math.max(0, g));
                    b = Math.min(255, Math.max(0, b));

                    // ピクセルを塗りつぶす
                    const x = (i - 1) * cellWidth;
                    const y = (j - 1) * cellHeight;

                    for (let py = 0; py < cellHeight; py++) {
                        for (let px = 0; px < cellWidth; px++) {
                            const pixelX = Math.floor(x + px);
                            const pixelY = Math.floor(y + py);

                            // カップの円形マスク
                            const pdx = pixelX - canvas.width / 2;
                            const pdy = pixelY - canvas.height / 2;
                            const pixelDist = Math.sqrt(pdx * pdx + pdy * pdy);

                            if (pixelX < canvas.width && pixelY < canvas.height &&
                                pixelDist <= canvas.width / 2) {
                                const idx = (pixelY * canvas.width + pixelX) * 4;
                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // メインループ
        function simulate() {
            vel_step(u, v, u_prev, v_prev, viscosity, DT);
            dens_step(dens, dens_prev, u, v, diffusion, DT);

            u_prev.fill(0);
            v_prev.fill(0);
            dens_prev.fill(0);

            // 速度を減衰させて、数秒で拡散が止まるようにする
            for (let i = 0; i < SIZE; i++) {
                u[i] *= 0.97;
                v[i] *= 0.97;
            }

            // 密度の減衰を非常に少なくする（ミルクのパターンが残る）
            for (let i = 0; i < SIZE; i++) {
                dens[i] *= 0.9995;
            }

            draw();
            requestAnimationFrame(simulate);
        }

        // コントロール
        document.getElementById('viscosity').addEventListener('input', (e) => {
            viscosity = e.target.value / 100000;
            document.getElementById('viscosity-value').textContent = viscosity.toFixed(6);
        });

        document.getElementById('diffusion').addEventListener('input', (e) => {
            diffusion = e.target.value / 1000000;
            document.getElementById('diffusion-value').textContent = diffusion.toFixed(6);
        });

        document.getElementById('force').addEventListener('input', (e) => {
            force = parseInt(e.target.value);
            document.getElementById('force-value').textContent = force;
        });

        document.getElementById('density').addEventListener('input', (e) => {
            densityAmount = parseInt(e.target.value);
            document.getElementById('density-value').textContent = densityAmount;
        });

        // プリセット機能
        function resetCoffee() {
            u.fill(0);
            v.fill(0);
            u_prev.fill(0);
            v_prev.fill(0);
            dens.fill(0);
            dens_prev.fill(0);

            // コーヒーの背景をランダムに
            for (let i = 0; i < SIZE; i++) {
                coffee[i] = Math.random() * 20;
            }
        }

        // 初期化
        resetCoffee();
        simulate();
    </script>
</body>
</html>